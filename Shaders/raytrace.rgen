#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_ray_tracing : enable

/*Константы*/

#define MAX_RECURSION_DEPTH 4

/*Вспомогательные типы*/

// Полезная нагрузка луча
struct RayPayload
{
    vec3 hitColor;
    bool done;

    vec3 newRayOrigin;
    vec3 newRayDirection;
    float newRayStrength;
};

/*Uniform*/

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;

layout(binding = 1, set = 0, rgba32f) uniform image2D image;

layout(binding = 0, set = 1, std140) uniform UniformCamera {
    mat4 _view;
    mat4 _proj;
    mat4 _camModel;
    vec3 _camPosition;
    float _fov;
};

/* Ввод - вывод */

// Результат трассировки лучом сцены
layout(location = 0) rayPayloadEXT RayPayload rayData;

/*Функции*/

// Вычислить вектор направления луча
vec3 calcRayDirection(float fov, float aspectRatio, vec2 fragCoord)
{
    // Преобразовать текстурные координаты (0;1) в клип-координаты экрана (-1;1)
    vec2 fragClipCoords = (fragCoord * 2.0) - vec2(1.0);

    // Вектор направления с учетом угла обзора (fov) и пропорций экрана (aspectRatio)
    vec3 direction = vec3(
        fragClipCoords.x * tan(radians(fov) / 2.0) * aspectRatio,
        -fragClipCoords.y * tan(radians(fov) / 2.0),
        -1.0);

    // Вектор в пространстве мира
    vec3 directionWorld = (_camModel * vec4(direction,0.0f)).xyz;

    // Вернуть нормализованный вектор
    return normalize(directionWorld);
}

// Основная функция - генерация луча
void main() 
{
    // Вычислить UV кооррдианты текущего пикселя
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);

    // Высилить пропорции области вида
    const float aspect = float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);

    // Начало луча в пространстве мира
    vec3 rayOrigin = (_camModel * vec4(0.0f,0.0f,0.0f,1.0f)).xyz;
    // Направление луча исходящего из текущего пикселя
    vec3 rayDirection = calcRayDirection(_fov, aspect, inUV);

    // Минимальные и максимальные значения расстрояния пересечения
    float tmin = 0.001;
	float tmax = 10000.0;

    // Итоговое значение цвета
    vec3 resultColor = vec3(0.0f);
    // Сила текущего луча (при отражении луч может терять силу)
    float currentRayStrngth = 1.0f;
    // Глубина рекурсии
    uint depth = 0;

    while(true)
    {
        // Трассировка сцены
        traceRayEXT(
            topLevelAS,            // Структура ускорения верхнего уровня
            gl_RayFlagsOpaqueEXT,  // Флаги трассировки
            0xff,                  // Флаги кулинга
            0,                     // Смещение в таблице SBT (хит-группа)
            0,                     // Шаг в таблице SBT 
            0,                     // Индекс для miss шейедра
            rayOrigin,             // Начало луча
            tmin,                  // Минимальная дальность
            rayDirection,          // Направлние луча
            tmax,                  // Максимальная дальность
            0);                    // Индекс полезной нагрузки на выходе (location = 0)

        // Накапливаем результирующий цвет из лучей
        resultColor += rayData.hitColor * currentRayStrngth;

        // Глубина увеличена
        depth++;

        // Если луч что был запущен - финальный, лтбо превышен лимит глубины - остановка
        if(rayData.done || depth >= MAX_RECURSION_DEPTH)
            break;    

        // Если это был не фмнальный луч (требудется отражение) - меняем начало, направление, силу луча
        currentRayStrngth  *=   rayData.newRayStrength;
        rayOrigin           =   rayData.newRayOrigin;
        rayDirection        =   rayData.newRayDirection;
        
        // Если луч не ударится в зеркальную поверхность - это завершит цикл
        rayData.done = true;
    }

    // Запись в изображение
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(resultColor, 1.0));
}
